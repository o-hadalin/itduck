{"version":3,"file":"vendor-dc46b456.js","sources":["../../node_modules/blaze-slider/dist/blaze-slider.esm.js"],"sourcesContent":["/* blaze-slider v1.9.3 by Manan Tank */\n/**\n * calculate pages and return\n */\nfunction calculatePages(slider) {\n    const { slidesToShow, slidesToScroll, loop } = slider.config;\n    const { isStatic, totalSlides } = slider;\n    const pages = [];\n    const lastIndex = totalSlides - 1;\n    // start with index 0, keep adding slidesToScroll to get the new page\n    for (let startIndex = 0; startIndex < totalSlides; startIndex += slidesToScroll) {\n        const _endIndex = startIndex + slidesToShow - 1;\n        const overflow = _endIndex > lastIndex;\n        if (overflow) {\n            // if not looped\n            if (!loop) {\n                // adjust the startIndex\n                const startIndex = lastIndex - slidesToShow + 1;\n                const lastPageIndex = pages.length - 1;\n                // create page only if adjusting the startIndex does not make it the same as previously saved page\n                if (pages.length === 0 ||\n                    (pages.length > 0 && pages[lastPageIndex][0] !== startIndex)) {\n                    pages.push([startIndex, lastIndex]);\n                }\n                break;\n            }\n            // if looped\n            else {\n                // adjust the endIndex\n                const endIndex = _endIndex - totalSlides;\n                pages.push([startIndex, endIndex]);\n            }\n        }\n        else {\n            pages.push([startIndex, _endIndex]);\n        }\n        // if static, only allow 1 iteration\n        if (isStatic) {\n            break;\n        }\n    }\n    return pages;\n}\n\n/**\n * calculate all possible states of given slider\n */\nfunction calculateStates(slider) {\n    const { totalSlides } = slider;\n    const { loop } = slider.config;\n    // get all possible pages\n    const pages = calculatePages(slider);\n    const states = [];\n    const lastPageIndex = pages.length - 1;\n    for (let pageIndex = 0; pageIndex < pages.length; pageIndex++) {\n        // calculate prev and next page index based on config\n        let nextPageIndex, prevPageIndex;\n        if (loop) {\n            nextPageIndex = pageIndex === lastPageIndex ? 0 : pageIndex + 1;\n            prevPageIndex = pageIndex === 0 ? lastPageIndex : pageIndex - 1;\n        }\n        else {\n            nextPageIndex =\n                pageIndex === lastPageIndex ? lastPageIndex : pageIndex + 1;\n            prevPageIndex = pageIndex === 0 ? 0 : pageIndex - 1;\n        }\n        const currentPageStartIndex = pages[pageIndex][0];\n        const nextPageStartIndex = pages[nextPageIndex][0];\n        const prevPageStartIndex = pages[prevPageIndex][0];\n        // calculate slides that need to be moved for transitioning to next and prev state from current state\n        let nextDiff = nextPageStartIndex - currentPageStartIndex;\n        if (nextPageStartIndex < currentPageStartIndex) {\n            nextDiff += totalSlides;\n        }\n        let prevDiff = currentPageStartIndex - prevPageStartIndex;\n        if (prevPageStartIndex > currentPageStartIndex) {\n            prevDiff += totalSlides;\n        }\n        states.push({\n            page: pages[pageIndex],\n            next: {\n                stateIndex: nextPageIndex,\n                moveSlides: nextDiff,\n            },\n            prev: {\n                stateIndex: prevPageIndex,\n                moveSlides: prevDiff,\n            },\n        });\n    }\n    return states;\n}\n\nconst START = 'start';\nconst END = 'end';\nconst DEV = process.env.NODE_ENV !== 'production';\n\n/**\n * it fixes below scenarios which are wrong (and adds a warning in console in development)\n * - config.slidesToShow greater than totalSlides\n * - config.slidesToScroll greater than config.slidesToShow which skips showing certain slides\n * - config.slidesToScroll too high such that it causes glitches\n */\nfunction fixSliderConfig(slider) {\n    const { slidesToScroll, slidesToShow } = slider.config;\n    const { totalSlides, config } = slider;\n    if (totalSlides < slidesToShow) {\n        if (DEV) {\n            console.warn('slidesToShow can not be larger than number of slides. Setting slidesToShow = totalSlides instead.');\n        }\n        config.slidesToShow = totalSlides;\n    }\n    if (totalSlides <= slidesToShow) {\n        // return because slidesToScroll does not need to be checked\n        return;\n    }\n    // detect slider skipping\n    if (slidesToScroll > slidesToShow) {\n        if (DEV) {\n            console.warn('slidesToScroll can not be greater than slidesToShow. Setting slidesToScroll = slidesToShow instead');\n        }\n        config.slidesToScroll = slidesToShow;\n    }\n    // detect slider jumping glitch\n    if (totalSlides < slidesToScroll + slidesToShow) {\n        const properSlidesToScroll = totalSlides - slidesToShow;\n        if (DEV) {\n            console.warn(`slidesToScroll = ${slidesToScroll} is too large for a slider with ${totalSlides} slides with slidesToShow=${slidesToShow}, setting max possible slidesToScroll = ${properSlidesToScroll} instead.`);\n        }\n        config.slidesToScroll = properSlidesToScroll;\n    }\n}\n\nclass Automata {\n    constructor(totalSlides, config) {\n        this.config = config;\n        this.totalSlides = totalSlides;\n        this.isTransitioning = false;\n        constructAutomata(this, totalSlides, config);\n    }\n    next(pages = 1) {\n        if (this.isTransitioning || this.isStatic)\n            return;\n        const { stateIndex } = this;\n        let slidesMoved = 0;\n        let newStateIndex = stateIndex;\n        for (let i = 0; i < pages; i++) {\n            const state = this.states[newStateIndex];\n            slidesMoved += state.next.moveSlides;\n            newStateIndex = state.next.stateIndex;\n        }\n        if (newStateIndex === stateIndex)\n            return;\n        this.stateIndex = newStateIndex;\n        return [stateIndex, slidesMoved];\n    }\n    prev(pages = 1) {\n        if (this.isTransitioning || this.isStatic)\n            return;\n        const { stateIndex } = this;\n        let slidesMoved = 0;\n        let newStateIndex = stateIndex;\n        for (let i = 0; i < pages; i++) {\n            const state = this.states[newStateIndex];\n            slidesMoved += state.prev.moveSlides;\n            newStateIndex = state.prev.stateIndex;\n        }\n        if (newStateIndex === stateIndex)\n            return;\n        this.stateIndex = newStateIndex;\n        return [stateIndex, slidesMoved];\n    }\n}\n// this will be called when slider is refreshed\nfunction constructAutomata(automata, totalSlides, config) {\n    automata.stateIndex = 0;\n    fixSliderConfig(automata);\n    automata.isStatic = totalSlides <= config.slidesToShow;\n    automata.states = calculateStates(automata);\n}\n\nfunction scrollPrev(slider, slideCount) {\n    const rAf = requestAnimationFrame;\n    if (!slider.config.loop) {\n        noLoopScroll(slider);\n    }\n    else {\n        // shift elements and apply negative transform to make it look like nothing changed\n        // disable transition\n        disableTransition(slider);\n        // apply negative transform\n        slider.offset = -1 * slideCount;\n        updateTransform(slider);\n        // and move the elements\n        wrapPrev(slider, slideCount);\n        const reset = () => {\n            rAf(() => {\n                enableTransition(slider);\n                rAf(() => {\n                    slider.offset = 0;\n                    updateTransform(slider);\n                    onSlideEnd(slider);\n                });\n            });\n        };\n        // if the scroll was done as part of dragging\n        // reset should be done after the dragging is completed\n        if (slider.isDragging) {\n            if (isTouch()) {\n                slider.track.addEventListener('touchend', reset, { once: true });\n            }\n            else {\n                slider.track.addEventListener('pointerup', reset, { once: true });\n            }\n        }\n        else {\n            rAf(reset);\n        }\n    }\n}\n// <--- move slider to left for showing content on right\nfunction scrollNext(slider, slideCount) {\n    const rAf = requestAnimationFrame;\n    if (!slider.config.loop) {\n        noLoopScroll(slider);\n    }\n    else {\n        // apply offset and let the slider scroll from  <- (right to left)\n        slider.offset = -1 * slideCount;\n        updateTransform(slider);\n        // once the transition is done\n        setTimeout(() => {\n            // remove the elements from start that are no longer visible and put them at the end\n            wrapNext(slider, slideCount);\n            disableTransition(slider);\n            // apply transform where the slider should go\n            slider.offset = 0;\n            updateTransform(slider);\n            rAf(() => {\n                rAf(() => {\n                    enableTransition(slider);\n                    onSlideEnd(slider);\n                });\n            });\n        }, slider.config.transitionDuration);\n    }\n}\nfunction onSlideEnd(slider) {\n    if (slider.onSlideCbs) {\n        const state = slider.states[slider.stateIndex];\n        const [firstSlideIndex, lastSlideIndex] = state.page;\n        slider.onSlideCbs.forEach((cb) => cb(slider.stateIndex, firstSlideIndex, lastSlideIndex));\n    }\n}\n\n// when loop is disabled, we must update the offset\nfunction noLoopScroll(slider) {\n    slider.offset = -1 * slider.states[slider.stateIndex].page[0];\n    updateTransform(slider);\n    onSlideEnd(slider);\n}\nfunction wrapPrev(slider, count) {\n    const len = slider.slides.length;\n    for (let i = 0; i < count; i++) {\n        // pick the last and move to first\n        const slide = slider.slides[len - 1];\n        // @ts-ignore\n        slider.track.prepend(slide);\n    }\n}\nfunction wrapNext(slider, count) {\n    for (let i = 0; i < count; i++) {\n        slider.track.append(slider.slides[0]);\n    }\n}\nfunction updateTransform(slider) {\n    const { track, offset, dragged } = slider;\n    if (offset === 0) {\n        track.style.transform = `translate3d(${dragged}px,0px,0px)`;\n    }\n    else {\n        track.style.transform = `translate3d(  calc( ${dragged}px + ${offset} * (var(--slide-width) + ${slider.config.slideGap})),0px,0px)`;\n    }\n}\nfunction enableTransition(slider) {\n    slider.track.style.transitionDuration = `${slider.config.transitionDuration}ms`;\n}\nfunction disableTransition(slider) {\n    slider.track.style.transitionDuration = `0ms`;\n}\n\nconst slideThreshold = 10;\nconst isTouch = () => 'ontouchstart' in window;\nfunction handlePointerDown(downEvent) {\n    const track = this;\n    const slider = track.slider;\n    if (slider.isTransitioning)\n        return;\n    slider.dragged = 0;\n    track.isScrolled = false;\n    track.startMouseClientX =\n        'touches' in downEvent ? downEvent.touches[0].clientX : downEvent.clientX;\n    if (!('touches' in downEvent)) {\n        // do not directly setPointerCapture on track - it blocks the click events\n        // https://github.com/GoogleChromeLabs/pointer-tracker/issues/4\n        const el = (downEvent.target || track);\n        el.setPointerCapture(downEvent.pointerId);\n    }\n    disableTransition(slider);\n    updateEventListener(track, 'addEventListener');\n}\nfunction handlePointerMove(moveEvent) {\n    const track = this;\n    const x = 'touches' in moveEvent ? moveEvent.touches[0].clientX : moveEvent.clientX;\n    const dragged = (track.slider.dragged = x - track.startMouseClientX);\n    const draggedAbs = Math.abs(dragged);\n    // consider dragging only if the user has dragged more than 5px\n    if (draggedAbs > 5) {\n        // track.setAttribute('data-dragging', 'true')\n        track.slider.isDragging = true;\n    }\n    // prevent vertical scrolling if horizontal scrolling is happening\n    if (draggedAbs > 15) {\n        moveEvent.preventDefault();\n    }\n    track.slider.dragged = dragged;\n    updateTransform(track.slider);\n    if (!track.isScrolled && track.slider.config.loop) {\n        if (dragged > slideThreshold) {\n            track.isScrolled = true;\n            track.slider.prev();\n        }\n    }\n}\nfunction handlePointerUp() {\n    const track = this;\n    const dragged = track.slider.dragged;\n    track.slider.isDragging = false;\n    updateEventListener(track, 'removeEventListener');\n    // reset drag\n    track.slider.dragged = 0;\n    updateTransform(track.slider);\n    enableTransition(track.slider);\n    if (!track.isScrolled) {\n        if (dragged < -1 * slideThreshold) {\n            track.slider.next();\n        }\n        else if (dragged > slideThreshold) {\n            track.slider.prev();\n        }\n    }\n}\nconst preventDefault = (event) => event.preventDefault();\n/**\n * drag based navigation for slider\n */\nfunction dragSupport(slider) {\n    // @ts-expect-error\n    const track = slider.track;\n    track.slider = slider;\n    const event = isTouch() ? 'touchstart' : 'pointerdown';\n    // @ts-expect-error\n    track.addEventListener(event, handlePointerDown);\n    // prevent click default when slider is being dragged or transitioning\n    track.addEventListener('click', (event) => {\n        if (slider.isTransitioning || slider.isDragging) {\n            event.preventDefault();\n            event.stopImmediatePropagation();\n            event.stopPropagation();\n        }\n    }, {\n        capture: true,\n    });\n    // prevent dragging of elements inside the slider\n    track.addEventListener('dragstart', preventDefault);\n}\nfunction updateEventListener(track, method) {\n    track[method]('contextmenu', handlePointerUp);\n    if (isTouch()) {\n        track[method]('touchend', handlePointerUp);\n        // @ts-expect-error\n        track[method]('touchmove', handlePointerMove);\n    }\n    else {\n        track[method]('pointerup', handlePointerUp);\n        // @ts-expect-error\n        track[method]('pointermove', handlePointerMove);\n    }\n}\n\nfunction handleAutoplay(slider) {\n    const config = slider.config;\n    if (!config.enableAutoplay)\n        return;\n    const dir = config.autoplayDirection === 'to left' ? 'next' : 'prev';\n    slider.autoplayTimer = setInterval(() => {\n        slider[dir]();\n    }, config.autoplayInterval);\n    if (config.stopAutoplayOnInteraction) {\n        slider.el.addEventListener(isTouch() ? 'touchstart' : 'mousedown', () => {\n            clearInterval(slider.autoplayTimer);\n        }, { once: true });\n    }\n}\n\nconst defaultConfig = {\n    // layout\n    slideGap: '20px',\n    slidesToScroll: 1,\n    slidesToShow: 1,\n    // behavior\n    loop: true,\n    // autoplay\n    enableAutoplay: false,\n    stopAutoplayOnInteraction: true,\n    autoplayInterval: 3000,\n    autoplayDirection: 'to left',\n    // pagination\n    enablePagination: true,\n    // transition\n    transitionDuration: 300,\n    transitionTimingFunction: 'ease',\n    draggable: true,\n};\nfunction createConfig(blazeConfig) {\n    // start with default config clone\n    const config = { ...defaultConfig };\n    for (const media in blazeConfig) {\n        // if the media matches, override the config with media config\n        if (window.matchMedia(media).matches) {\n            const mediaConfig = blazeConfig[media];\n            for (const key in mediaConfig) {\n                // @ts-expect-error\n                config[key] = mediaConfig[key];\n            }\n        }\n    }\n    return config;\n}\n\nfunction handleNavigation(slider) {\n    const prev = slider.el.querySelector('.blaze-prev');\n    const next = slider.el.querySelector('.blaze-next');\n    if (prev) {\n        prev.onclick = () => {\n            slider.prev();\n        };\n    }\n    if (next) {\n        next.onclick = () => {\n            slider.next();\n        };\n    }\n}\n\nfunction handlePagination(slider) {\n    if (!slider.config.enablePagination || slider.isStatic)\n        return;\n    const paginationContainer = slider.el.querySelector('.blaze-pagination');\n    if (!paginationContainer)\n        return;\n    slider.paginationButtons = [];\n    const total = slider.states.length;\n    for (let index = 0; index < total; index++) {\n        const button = document.createElement('button');\n        slider.paginationButtons.push(button);\n        button.textContent = 1 + index + '';\n        button.ariaLabel = `${index + 1} of ${total}`;\n        paginationContainer.append(button);\n        // @ts-expect-error\n        button.slider = slider;\n        // @ts-expect-error\n        button.index = index;\n        // @ts-expect-error\n        button.onclick = handlePaginationButtonClick;\n    }\n    // initially the first button is active\n    slider.paginationButtons[0].classList.add('active');\n}\nfunction handlePaginationButtonClick() {\n    const index = this.index;\n    const slider = this.slider;\n    const stateIndex = slider.stateIndex;\n    const loop = slider.config.loop;\n    const diff = Math.abs(index - stateIndex);\n    const inverseDiff = slider.states.length - diff;\n    const isDiffLargerThanHalf = diff > slider.states.length / 2;\n    const scrollOpposite = isDiffLargerThanHalf && loop;\n    // if target state is ahead of current state\n    if (index > stateIndex) {\n        // but the diff is too large\n        if (scrollOpposite) {\n            // scroll in opposite direction to reduce scrolling\n            slider.prev(inverseDiff);\n        }\n        else {\n            // scroll normally\n            slider.next(diff);\n        }\n    }\n    // if target state is before current state\n    else {\n        // but the diff is too large\n        if (scrollOpposite) {\n            // scroll in opposite direction\n            slider.next(inverseDiff);\n        }\n        else {\n            // scroll normally\n            slider.prev(diff);\n        }\n    }\n}\n\nfunction isTransitioning(slider, time = slider.config.transitionDuration) {\n    slider.isTransitioning = true;\n    setTimeout(() => {\n        slider.isTransitioning = false;\n    }, time);\n}\nclass BlazeSlider extends Automata {\n    constructor(blazeSliderEl, blazeConfig) {\n        const track = blazeSliderEl.querySelector('.blaze-track');\n        const slides = track.children;\n        const config = blazeConfig\n            ? createConfig(blazeConfig)\n            : { ...defaultConfig };\n        super(slides.length, config);\n        this.config = config;\n        this.el = blazeSliderEl;\n        this.track = track;\n        this.slides = slides;\n        this.offset = 0;\n        this.dragged = 0;\n        this.isDragging = false;\n        // @ts-ignore - for debugging\n        this.el.blazeSlider = this;\n        this.passedConfig = blazeConfig;\n        const slider = this;\n        track.slider = slider;\n        construct(config, slider);\n        // throttled to refresh every 200ms when resizing\n        let ignoreResize = false;\n        let width = 0;\n        window.addEventListener('resize', () => {\n            if (width === 0) {\n                width = window.innerWidth;\n                return;\n            }\n            const newWidth = window.innerWidth;\n            // ignore height change - only refresh if the width is changed\n            if (width === newWidth)\n                return;\n            width = newWidth;\n            if (!ignoreResize) {\n                ignoreResize = true;\n                setTimeout(() => {\n                    slider.refresh();\n                    ignoreResize = false;\n                }, 200);\n            }\n        });\n    }\n    next(count) {\n        if (this.isTransitioning)\n            return;\n        const transition = super.next(count);\n        if (!transition) {\n            isTransitioning(this);\n            return;\n        }\n        const [prevStateIndex, slideCount] = transition;\n        handleStateChange(this, prevStateIndex);\n        isTransitioning(this);\n        scrollNext(this, slideCount);\n    }\n    prev(count) {\n        if (this.isTransitioning)\n            return;\n        const transition = super.prev(count);\n        if (!transition) {\n            isTransitioning(this);\n            return;\n        }\n        const [prevStateIndex, slideCount] = transition;\n        handleStateChange(this, prevStateIndex);\n        isTransitioning(this);\n        scrollPrev(this, slideCount);\n    }\n    stopAutoplay() {\n        clearInterval(this.autoplayTimer);\n    }\n    destroy() {\n        // remove side effects that won't be overridden by construct()\n        // remove old drag event handler\n        this.track.removeEventListener(isTouch() ? 'touchstart' : 'pointerdown', \n        // @ts-expect-error\n        handlePointerDown);\n        // stop autoplay\n        this.stopAutoplay();\n        // remove pagination buttons\n        this.paginationButtons?.forEach((button) => button.remove());\n        // remove classes\n        this.el.classList.remove('static');\n        this.el.classList.remove(START);\n    }\n    refresh() {\n        const newConfig = this.passedConfig\n            ? createConfig(this.passedConfig)\n            : { ...defaultConfig };\n        this.destroy();\n        construct(newConfig, this);\n    }\n    /**\n     * Subscribe for slide change event\n     * Returns a function to unsubscribe from slide change event\n     */\n    onSlide(cb) {\n        if (!this.onSlideCbs)\n            this.onSlideCbs = new Set();\n        this.onSlideCbs.add(cb);\n        return () => this.onSlideCbs.delete(cb);\n    }\n}\nfunction handleStateChange(slider, prevStateIndex) {\n    const classList = slider.el.classList;\n    const stateIndex = slider.stateIndex;\n    const buttons = slider.paginationButtons;\n    if (!slider.config.loop) {\n        if (stateIndex === 0) {\n            classList.add(START);\n        }\n        else {\n            classList.remove(START);\n        }\n        if (stateIndex === slider.states.length - 1) {\n            classList.add(END);\n        }\n        else {\n            classList.remove(END);\n        }\n    }\n    if (buttons && slider.config.enablePagination) {\n        buttons[prevStateIndex].classList.remove('active');\n        buttons[stateIndex].classList.add('active');\n    }\n}\nfunction construct(config, slider) {\n    const track = slider.track;\n    slider.slides = track.children;\n    slider.offset = 0;\n    slider.config = config;\n    constructAutomata(slider, slider.totalSlides, config);\n    // if a side effect is in condition - make sure to add it for both conditions - so it gets cleaned up\n    // when refresh is called\n    if (!config.loop) {\n        slider.el.classList.add(START);\n    }\n    if (config.enableAutoplay && !config.loop) {\n        if (DEV) {\n            console.warn('enableAutoplay:true is not consistent with loop:false, auto-fixing with enableAutoplay:false');\n        }\n        config.enableAutoplay = false;\n    }\n    track.style.transitionProperty = 'transform';\n    track.style.transitionTimingFunction = slider.config.transitionTimingFunction;\n    track.style.transitionDuration = `${slider.config.transitionDuration}ms`;\n    const { slidesToShow, slideGap } = slider.config;\n    slider.el.style.setProperty('--slides-to-show', slidesToShow + '');\n    slider.el.style.setProperty('--slide-gap', slideGap);\n    if (!slider.isStatic) {\n        if (config.draggable) {\n            dragSupport(slider);\n        }\n    }\n    else {\n        slider.el.classList.add('static');\n    }\n    handlePagination(slider);\n    handleAutoplay(slider);\n    handleNavigation(slider);\n    updateTransform(slider);\n}\n\nexport { BlazeSlider as default };\n"],"names":["calculatePages","slider","slidesToShow","slidesToScroll","loop","isStatic","totalSlides","pages","lastIndex","startIndex","_endIndex","endIndex","lastPageIndex","calculateStates","states","pageIndex","nextPageIndex","prevPageIndex","currentPageStartIndex","nextPageStartIndex","prevPageStartIndex","nextDiff","prevDiff","START","END","fixSliderConfig","config","properSlidesToScroll","Automata","constructAutomata","stateIndex","slidesMoved","newStateIndex","i","state","automata","scrollPrev","slideCount","rAf","noLoopScroll","disableTransition","updateTransform","wrapPrev","reset","enableTransition","onSlideEnd","isTouch","scrollNext","wrapNext","firstSlideIndex","lastSlideIndex","cb","count","len","slide","track","offset","dragged","slideThreshold","handlePointerDown","downEvent","updateEventListener","handlePointerMove","moveEvent","x","draggedAbs","handlePointerUp","preventDefault","event","dragSupport","method","handleAutoplay","dir","defaultConfig","createConfig","blazeConfig","media","mediaConfig","key","handleNavigation","prev","next","handlePagination","paginationContainer","total","index","button","handlePaginationButtonClick","diff","inverseDiff","scrollOpposite","isTransitioning","time","BlazeSlider","blazeSliderEl","slides","construct","ignoreResize","width","newWidth","transition","prevStateIndex","handleStateChange","_a","newConfig","classList","buttons","slideGap"],"mappings":"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","x_google_ignoreList":[0]}